<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AI Video Call + Chat â€” Fixed</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--bg:#f4f6f9;--accent:#0b76f6;--muted:#6b7280}
    *{box-sizing:border-box}
    body{font-family:Inter,system-ui,Arial,sans-serif;background:var(--bg);margin:0;color:#111}
    .app{max-width:1100px;margin:18px auto;padding:18px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{margin:0;font-size:18px}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:12px}
    input,button,select{padding:8px 10px;font-size:14px;border-radius:8px;border:1px solid #d1d5db}
    button{background:var(--accent);color:#fff;border:none;cursor:pointer}
    button.ghost{background:#fff;color:var(--accent);border:1px solid var(--accent)}
    button:disabled{opacity:.5;cursor:not-allowed}
    .stage{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px;margin-top:18px}
    .tile{background:#000;border-radius:10px;overflow:hidden;position:relative;height:160px;display:flex;align-items:center;justify-content:center}
    video{width:100%;height:100%;object-fit:cover;display:block}
    .label{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,0.45);color:#fff;padding:4px 8px;border-radius:6px;font-size:12px}
    .meta{position:absolute;right:8px;top:8px;background:rgba(0,0,0,0.45);color:#fff;padding:4px 8px;border-radius:6px;font-size:11px}
    .local .label{background:rgba(15,23,42,.6)}
    .chat{margin-top:18px;background:#fff;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,.06)}
    #messages{height:200px;overflow:auto;border-radius:8px;padding:8px;background:#f8fafc;border:1px solid #eef2ff}
    .msg{padding:6px 10px;border-radius:8px;margin:6px 0;display:inline-block;max-width:80%}
    .me{background:var(--accent);color:#fff;float:right}
    .peer{background:#eef2ff;color:#000;float:left}
    .small{font-size:13px;color:var(--muted)}
    .notice{ position:fixed; right:16px; top:16px; background:rgba(0,0,0,0.75); color:#fff; padding:10px 14px; border-radius:10px; z-index:1200; font-size:13px; }
    #membersList{margin-left:8px}
    @media (max-width:600px){.tile{height:140px}}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>ðŸŽ¥ AI Video Call + ðŸ’¬ Chat</h1>
        <div class="small">Client detects device/timezone. Server will show who is likely from US.</div>
      </div>
      <div class="small">Socket ID: <span id="sid">-</span></div>
    </header>

    <div class="controls">
      <label>Name: <input id="name" placeholder="Your name" /></label>
      <label>Room: <input id="room" value="testroom" /></label>
      <button id="joinBtn">Join Room</button>
      <button id="startCallBtn" disabled>Start Call</button>
      <button id="hangupBtn" disabled class="ghost">Leave</button>

      <div style="width:1px;background:#e6edf3;margin:0 6px; height:28px"></div>

      <button id="audioBtn" disabled>Mute</button>
      <button id="camBtn" disabled>Cam Off</button>
      <button id="flipBtn" disabled>Flip Camera</button>
      <button id="screenBtn" disabled>Share Screen</button>

      <div id="membersList" class="small">Participants: <span id="count">0</span></div>
    </div>

    <div class="stage" id="stage"></div>

    <div class="chat">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3 style="margin:0">ðŸ’¬ Chat</h3>
        <div class="small">Active: <span id="count2">0</span></div>
      </div>
      <div id="messages"></div>
      <div style="margin-top:8px; display:flex; gap:8px;">
        <input id="chatInput" placeholder="Type message..." style="flex:1" />
        <button id="sendBtn">Send</button>
      </div>
    </div>
  </div>

  <div id="noticeContainer"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const sidSpan = document.getElementById('sid');
    const nameInput = document.getElementById('name');
    const roomInput = document.getElementById('room');
    const joinBtn = document.getElementById('joinBtn');
    const startCallBtn = document.getElementById('startCallBtn');
    const hangupBtn = document.getElementById('hangupBtn');
    const audioBtn = document.getElementById('audioBtn');
    const camBtn = document.getElementById('camBtn');
    const flipBtn = document.getElementById('flipBtn');
    const screenBtn = document.getElementById('screenBtn');
    const stage = document.getElementById('stage');
    const messagesDiv = document.getElementById('messages');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const countSpan = document.getElementById('count');
    const countSpan2 = document.getElementById('count2');
    const membersList = document.getElementById('membersList');

    let localStream = null, cameraTrack = null, audioEnabled = true;
    let screenStream = null, isSharingScreen = false;
    let currentDeviceId = null;
    let peers = {}; // peerId -> { pc, videoSender, audioSender, el, videoEl, name, meta }
    let room = null;
    let callStarted = false;
    const STUN = { urls: 'stun:stun.l.google.com:19302' };

    // helper: show notice
    function showNotice(text, ttl = 2500){
      const el = document.createElement('div');
      el.className = 'notice';
      el.textContent = text;
      document.body.appendChild(el);
      setTimeout(()=> el.remove(), ttl);
    }

    // detect client meta
    function detectClientMeta() {
      const ua = navigator.userAgent || '';
      const isMobile = /Mobi|Android|iPhone|iPad|iPod|Mobile/i.test(ua);
      const platform = navigator.platform || '';
      const language = navigator.language || navigator.userLanguage || '';
      let timezone = 'unknown';
      try { timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || timezone; } catch(e){}
      let countryGuess = null;
      if (language && language.toLowerCase().includes('en-us')) countryGuess = 'US';
      if (timezone && timezone.toLowerCase().includes('america')) countryGuess = 'US';
      const deviceType = isMobile ? 'mobile' : 'desktop';
      return { isMobile, deviceType, platform, language, timezone, countryGuess, userAgent: ua };
    }

    function createTile(id, label, meta = {}, isLocal=false){
      const wrapper = document.createElement('div');
      wrapper.className = 'tile ' + (isLocal ? 'local' : '');
      wrapper.id = 'tile-' + id;
      const v = document.createElement('video'); v.autoplay = true; v.playsInline = true; v.id = 'video-' + id;
      if(isLocal) { v.muted = true; v.style.transform = 'scaleX(-1)'; }
      const lab = document.createElement('div'); lab.className = 'label'; lab.textContent = label;
      const metaEl = document.createElement('div'); metaEl.className = 'meta';
      const badges = [];
      if(meta && meta.countryGuess === 'US') badges.push('ðŸ‡ºðŸ‡¸ US');
      if(meta && meta.deviceType) badges.push(meta.deviceType);
      metaEl.textContent = badges.join(' â€¢ ');
      wrapper.appendChild(v); wrapper.appendChild(lab); wrapper.appendChild(metaEl);
      return { wrapper, videoEl: v, labelEl: lab, metaEl };
    }

    function updateCountsUI(membersArray){
      const count = membersArray ? membersArray.length : (Object.keys(peers).length || 0);
      countSpan.textContent = count;
      countSpan2.textContent = count;
      // render simple members list text
      if(Array.isArray(membersArray)){
        const names = membersArray.map(m => m.name || 'Anonymous');
        membersList.innerHTML = 'Participants: ' + names.join(', ');
      } else {
        membersList.innerHTML = 'Participants: ' + (Object.keys(peers).map(id => peers[id].name || 'Someone').join(', ') || '0');
      }
    }

    function showLocal(name, meta){
      const id = socket.id || 'local';
      if(document.getElementById('tile-'+id)) return;
      const { wrapper, videoEl, labelEl, metaEl } = createTile(id, name + ' (You)', meta, true);
      stage.prepend(wrapper);
      if(localStream) videoEl.srcObject = localStream;
      peers[id] = peers[id] || {};
      peers[id].el = wrapper; peers[id].videoEl = videoEl; peers[id].name = name; peers[id].meta = meta;
      updateCountsUI();
    }

    function addRemote(id, name='Peer', meta = {}) {
      if(document.getElementById('tile-'+id)) {
        const lbl = document.querySelector('#tile-' + id + ' .label');
        const metaEl = document.querySelector('#tile-' + id + ' .meta');
        if(lbl) lbl.textContent = name;
        if(metaEl){
          const badges = [];
          if(meta && meta.countryGuess === 'US') badges.push('ðŸ‡ºðŸ‡¸ US');
          if(meta && meta.deviceType) badges.push(meta.deviceType);
          metaEl.textContent = badges.join(' â€¢ ');
        }
        peers[id] = peers[id] || {};
        peers[id].name = name; peers[id].meta = meta;
        updateCountsUI();
        return;
      }
      const { wrapper, videoEl, labelEl, metaEl } = createTile(id, name || 'Peer', meta, false);
      stage.appendChild(wrapper);
      peers[id] = peers[id] || {};
      peers[id].el = wrapper; peers[id].videoEl = videoEl; peers[id].name = name; peers[id].meta = meta;
      updateCountsUI();
    }

    function removePeer(id){
      if(peers[id]){
        try{ if(peers[id].pc) peers[id].pc.close(); }catch(e){}
        if(peers[id].el) peers[id].el.remove();
        delete peers[id];
      }
      updateCountsUI();
    }

    function applyAudioState(){
      audioEnabled = !!audioEnabled;
      if(localStream){
        localStream.getAudioTracks().forEach(t => {
          try{ t.enabled = audioEnabled; } catch(e){/*ignore*/ }
        });
      }
      audioBtn.textContent = audioEnabled ? 'Mute' : 'Unmute';
    }

    function cameraConstraintsForMeta(meta) {
      const desktop = { video: { width: { ideal: 1280 }, height: { ideal: 720 } }, audio: true };
      const mobile = { video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }, audio: true };
      if (!meta) return desktop;
      if (meta.isMobile) return mobile;
      if (window.screen && Math.min(window.screen.width, window.screen.height) < 700) return mobile;
      return desktop;
    }

    // ===== NEW: require name on client before join =====
    joinBtn.onclick = async () => {
      const rawName = (nameInput.value || '').trim();
      if (!rawName) {
        showNotice('à¤•à¥ƒà¤ªà¤¯à¤¾ à¤…à¤ªà¤¨à¤¾ à¤¨à¤¾à¤® à¤¦à¤°à¥à¤œ à¤•à¤°à¥‡à¤‚ à¤¤à¤¾à¤•à¤¿ à¤†à¤ª à¤œà¥à¤¡à¤¼ à¤¸à¤•à¥‡à¤‚', 3000);
        nameInput.focus();
        return;
      }

      room = roomInput.value.trim();
      if(!room) {
        showNotice('Enter a room name', 2500);
        roomInput.focus();
        return;
      }

      joinBtn.disabled = true;
      try {
        const meta = detectClientMeta();
        const constraints = cameraConstraintsForMeta(meta);

        // request media only after name validation
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraTrack = localStream.getVideoTracks()[0];
        currentDeviceId = cameraTrack ? (cameraTrack.getSettings().deviceId || null) : null;

        // preserve audioEnabled state (default true)
        audioEnabled = localStream.getAudioTracks().length ? localStream.getAudioTracks()[0].enabled : audioEnabled;
        applyAudioState();

        // show local preview and enable controls
        showLocal(rawName, meta);
        audioBtn.disabled = false; camBtn.disabled = false; flipBtn.disabled = false; screenBtn.disabled = false;
        startCallBtn.disabled = false; hangupBtn.disabled = true;

        // emit join with clientMeta and name
        socket.emit('join', { room, name: rawName, clientMeta: meta });
      } catch (e) {
        alert('Camera/Mic error: ' + e.message);
        joinBtn.disabled = false;
      }
    };

    // socket handlers
    socket.on('connect', ()=>{ sidSpan.textContent = socket.id; });

    // server enforced: require-name
    socket.on('require-name', ({ message }) => {
      showNotice(message || 'Please provide a name to join', 3500);
      joinBtn.disabled = false;
      nameInput.focus();
    });

    // structured existing peers
    socket.on('existingPeers', list=>{
      (list || []).forEach(p => {
        if(p.id === socket.id) return;
        addRemote(p.id, p.name, p.meta || {});
        if(callStarted) initPeer(p.id, true).catch(e=>console.warn(e));
      });
    });

    socket.on('peer-joined', async ({id, name, meta})=>{
      if(id === socket.id) return;
      addRemote(id, name, meta || {});
      showNotice(`${name || 'Peer'} joined ${(meta && meta.countryGuess) ? '('+meta.countryGuess+')' : ''}`);
      if(callStarted) initPeer(id, true).catch(e=>console.warn(e));
    });

    socket.on('peer-left', ({id, name})=>{
      showNotice(`${name || 'Peer'} left`);
      removePeer(id);
    });

    // roomMembers: payload { members: [{id,name,meta}], count }
    socket.on('roomMembers', payload => {
      const members = (payload && payload.members) ? payload.members : (Array.isArray(payload) ? payload : []);
      members.forEach(m => {
        if(m.id === socket.id){
          showLocal(m.name || (nameInput.value || 'You'), m.meta || {});
        } else {
          addRemote(m.id, m.name, m.meta || {});
        }
      });
      // remove peers not present
      const memberIds = new Set(members.map(m => m.id));
      Object.keys(peers).forEach(id => {
        if(id !== socket.id && !memberIds.has(id)) removePeer(id);
      });
      updateCountsUI(members);
    });

    socket.on('roomDelta', delta => {
      if(!delta) return;
      if(delta.joined && delta.joined.length){
        const names = delta.joined.map(x => x.name || 'Someone');
        showNotice('Joined: ' + names.join(', '));
        delta.joined.forEach(j => addRemote(j.id, j.name, j.meta || {}));
      }
      if(delta.left && delta.left.length){
        const names = delta.left.map(x => x.name || 'Someone');
        showNotice('Left: ' + names.join(', '));
        delta.left.forEach(l => removePeer(l.id));
      }
    });

    // chat
    sendBtn.onclick=()=>{
      const text = chatInput.value.trim(); if(!text) return;
      const name = (nameInput.value || '').trim() || 'Anonymous';
      socket.emit('chatMessage', { room, text });
      appendMsg('me', name + ': ' + text);
      chatInput.value = '';
    };
    socket.on('chatMessage', ({ from, name, text })=>{
      appendMsg('peer', (name || 'Peer') + ': ' + text);
    });

    function appendMsg(kind, text){
      const d=document.createElement('div'); d.className='msg '+(kind==='me'?'me':'peer'); d.textContent=text;
      messagesDiv.appendChild(d); messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // initPeer: create RTCPeerConnection and add tracks
    async function initPeer(id, isInitiator){
      if(peers[id] && peers[id].pc) return peers[id].pc;
      addRemote(id, peers[id] && peers[id].name ? peers[id].name : 'Peer', peers[id] && peers[id].meta ? peers[id].meta : {});
      const pc = new RTCPeerConnection({ iceServers: [STUN] });
      peers[id] = peers[id] || {};
      peers[id].pc = pc;

      pc.onicecandidate = e => { if(e.candidate) socket.emit('signal', { to: id, data: { candidate: e.candidate } }); };

      pc.ontrack = e => {
        const el = peers[id].videoEl || document.getElementById('video-'+id);
        if(el) {
          el.srcObject = e.streams[0];
          el.style.transform = ''; // remote not mirrored
        }
      };

      // add local tracks (if available). addTrack returns RTCRtpSender which we store for replaceTrack
      if(localStream){
        localStream.getTracks().forEach(track => {
          try{
            const sender = pc.addTrack(track, localStream);
            if(track.kind === 'video') peers[id].videoSender = sender;
            if(track.kind === 'audio') peers[id].audioSender = sender;
          }catch(e){ console.warn('addTrack failed', e); }
        });
      }

      if(isInitiator){
        try{
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit('signal', { to: id, data: pc.localDescription });
        }catch(e){ console.warn('createOffer failed', e); }
      }
      return pc;
    }

    // handle incoming signals from server (offer/answer/candidate)
    socket.on('signal', async ({ from, data })=>{
      try{
        if(!from || !data) return;
        // ensure peer exists
        const pc = await initPeer(from, false);
        if(data.type === 'offer'){
          await pc.setRemoteDescription(new RTCSessionDescription(data));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('signal', { to: from, data: pc.localDescription });
        } else if(data.type === 'answer'){
          await pc.setRemoteDescription(new RTCSessionDescription(data));
        } else if(data.candidate){
          await pc.addIceCandidate(data.candidate);
        }
      }catch(e){ console.warn('signal handling failed', e); }
    });

    // START CALL
    startCallBtn.onclick = async ()=>{
      if(!room) return alert('Join a room first');
      if(callStarted) return;
      callStarted = true;
      startCallBtn.disabled = true;
      hangupBtn.disabled = false;
      const otherIds = Object.keys(peers).filter(id => id !== socket.id);
      for(const id of otherIds){
        try{ await initPeer(id, true); }catch(e){ console.warn('start call init failed', e); }
      }
      showNotice('Call started');
    };

    // LEAVE
    hangupBtn.onclick = ()=>{
      socket.emit('leave');
      Object.keys(peers).forEach(id=>{
        if(peers[id] && peers[id].pc) { try{ peers[id].pc.close(); }catch(e){} }
        const tile = document.getElementById('tile-'+id); if(tile) tile.remove();
      });
      peers = {};
      callStarted = false;
      if(localStream){
        localStream.getTracks().forEach(t=>{ try{ t.stop(); }catch(e){} });
        localStream = null; cameraTrack = null;
      }
      if(screenStream){
        screenStream.getTracks().forEach(t=>{ try{ t.stop(); }catch(e){} });
        screenStream = null; isSharingScreen = false;
      }
      joinBtn.disabled = false; startCallBtn.disabled = true; hangupBtn.disabled = true;
      audioBtn.disabled = true; camBtn.disabled = true; flipBtn.disabled = true; screenBtn.disabled = true;
      updateCountsUI([]);
      showNotice('Left room');
    };

    // AUDIO toggle
    audioBtn.onclick = ()=>{
      if(!localStream) return alert('Join room and allow microphone first');
      const audioTracks = localStream.getAudioTracks();
      if(!audioTracks || audioTracks.length === 0) return alert('No audio track available');
      audioEnabled = !audioEnabled;
      applyAudioState();
      // also ensure senders (peers) reflect the state (no change required normally, but keep consistent)
      Object.values(peers).forEach(p => {
        if(p.audioSender && p.audioSender.track) {
          try{ p.audioSender.track.enabled = audioEnabled; } catch(e){}
        }
      });
    };

    // CAM toggle (hide/show)
    camBtn.onclick = ()=>{
      if(!localStream) return alert('Join room and allow camera first');
      const videoTracks = localStream.getVideoTracks();
      if(!videoTracks || videoTracks.length === 0) return alert('No video track available');
      const enabled = videoTracks[0].enabled;
      videoTracks.forEach(t => t.enabled = !enabled);
      camBtn.textContent = enabled ? 'Cam On' : 'Cam Off';
    };

    // Flip camera (preserve audio state)
    flipBtn.onclick = async ()=>{
      try{
        if(!localStream) return alert('Join room and allow camera first');
        const devices = await navigator.mediaDevices.enumerateDevices();
        const vids = devices.filter(d => d.kind === 'videoinput');
        if(vids.length < 2) return alert('No second camera found');

        let idx = vids.findIndex(v => v.deviceId === currentDeviceId);
        idx = (idx + 1) % vids.length;
        const nextId = vids[idx].deviceId;

        if(isSharingScreen){
          alert('Stop screen sharing to flip camera.');
          return;
        }

        // Request only the new video track (audio:false), preserve localStream's audio tracks
        const newCamStream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: nextId } }, audio: false });
        const newTrack = newCamStream.getVideoTracks()[0];
        if(!newTrack) throw new Error('No video track from new camera');

        // stop previous video track but keep audio tracks intact
        if(cameraTrack){
          try{ localStream.removeTrack(cameraTrack); }catch(e){}
          try{ cameraTrack.stop(); }catch(e){}
        }

        localStream.addTrack(newTrack);
        cameraTrack = newTrack;
        currentDeviceId = nextId;

        const localVid = document.getElementById('video-'+socket.id);
        if(localVid) localVid.srcObject = localStream;

        // replace track on existing peer senders (preferred)
        Object.values(peers).forEach(async p => {
          if(p.videoSender && p.videoSender.replaceTrack) {
            try{ await p.videoSender.replaceTrack(cameraTrack); } catch(e){ console.warn('replaceTrack failed', e); }
          } else if(p && p.pc) {
            try{
              p.pc.getSenders().forEach(s => {
                if(s.track && s.track.kind === 'video') { try{ p.pc.removeTrack(s); }catch(e){} }
              });
              const sender = p.pc.addTrack(cameraTrack, localStream);
              p.videoSender = sender;
            }catch(e){ console.warn('fallback replace failed', e); }
          }
        });

        // keep audio state consistent
        applyAudioState();
      }catch(e){ alert('Flip failed: '+e.message); }
    };

    // SCREEN SHARE toggle (preserve audio)
    screenBtn.onclick = async ()=>{
      if(!localStream) return alert('Join room and allow camera first');

      if(!isSharingScreen){
        try{
          screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
          const screenTrack = screenStream.getVideoTracks()[0];
          if(!screenTrack) throw new Error('No screen track');

          screenTrack.onended = () => { stopScreenShare(); };

          // remove camera video track but keep audio tracks
          if(cameraTrack){
            try{ localStream.removeTrack(cameraTrack); }catch(e){}
            try{ cameraTrack.stop(); }catch(e){}
          }

          localStream.addTrack(screenTrack);
          isSharingScreen = true;

          const localVid = document.getElementById('video-'+socket.id);
          if(localVid){ localVid.srcObject = localStream; localVid.style.transform = 'none'; }

          Object.values(peers).forEach(async p => {
            if(p.videoSender && p.videoSender.replaceTrack) {
              try{ await p.videoSender.replaceTrack(screenTrack); } catch(e){ console.warn('replaceTrack failed', e); }
            } else if(p && p.pc) {
              try{
                p.pc.getSenders().forEach(s => {
                  if(s.track && s.track.kind === 'video') { try{ p.pc.removeTrack(s); }catch(e){} }
                });
                const sender = p.pc.addTrack(screenTrack, localStream);
                p.videoSender = sender;
              }catch(e){ console.warn('fallback replace failed', e); }
            }
          });

          screenBtn.textContent = 'Stop Sharing';
          // ensure audio state persists
          applyAudioState();

        } catch(e){ alert('Screen share failed: '+e.message); }
      } else {
        stopScreenShare();
      }
    };

    async function stopScreenShare(){
      if(!isSharingScreen) return;
      try{
        if(screenStream) screenStream.getTracks().forEach(t=>{ try{ t.stop(); }catch(e){} });
        screenStream = null;

        // get camera track again (request audio:false to avoid creating duplicate audio tracks)
        const camStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        const newCamTrack = camStream.getVideoTracks()[0];
        if(!newCamTrack) throw new Error('Could not get camera after screen share');

        // remove any video tracks left in localStream (these are screen tracks)
        localStream.getVideoTracks().forEach(t => {
          try{ localStream.removeTrack(t); }catch(e){}
          try{ t.stop(); }catch(e){}
        });

        localStream.addTrack(newCamTrack);
        cameraTrack = newCamTrack;
        isSharingScreen = false;

        const localVid = document.getElementById('video-'+socket.id);
        if(localVid){ localVid.srcObject = localStream; localVid.style.transform = 'scaleX(-1)'; }

        Object.values(peers).forEach(async p => {
          if(p.videoSender && p.videoSender.replaceTrack) {
            try{ await p.videoSender.replaceTrack(cameraTrack); } catch(e){ console.warn('replaceTrack failed', e); }
          } else if(p && p.pc) {
            try{
              p.pc.getSenders().forEach(s => {
                if(s.track && s.track.kind === 'video') { try{ p.pc.removeTrack(s); }catch(e){} }
              });
              const sender = p.pc.addTrack(cameraTrack, localStream);
              p.videoSender = sender;
            }catch(e){ console.warn('fallback replace failed', e); }
          }
        });

        screenBtn.textContent = 'Share Screen';
        applyAudioState();
      }catch(e){
        console.warn('stopScreenShare error', e);
        screenBtn.textContent = 'Share Screen';
        isSharingScreen = false;
      }
    }

    // gracefully notify leave on tab close
    window.addEventListener('beforeunload', ()=>{ try{ socket.emit('leave'); }catch(e){} });
  </script>
</body>
</html>