<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Video Call â€” Working Client (fixed fullscreen & mobile)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b1220; --muted:#9aa7bd; --accent:#0b76f6;
    }
    body{font-family:Inter,Arial,sans-serif;background:var(--bg);color:#e6eef8;padding:14px;margin:0}
    .top{display:flex;gap:12px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
    input,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{background:var(--accent);color:#fff;border:none;cursor:pointer}
    button.ghost{background:transparent;border:1px solid var(--accent);color:var(--accent)}
    button:disabled{opacity:.5;cursor:not-allowed}
    .stage{
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(220px,1fr));
      gap:10px;
      align-items:start;
    }

    /* Tile */
    .tile{
      background:#000;
      border-radius:10px;
      overflow:hidden;
      position:relative;
      /* use aspect ratio to prevent stretching */
      height: auto;
      aspect-ratio: 16 / 9;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .tile.fullscreen-share{ grid-column: 1 / -1; height: 62vh; } /* when someone shares screen, make tile large */
    /* video fills tile but keeps aspect using object-fit */
    video{width:100%;height:100%;display:block;object-fit:cover;transform-origin:center center}
    /* when we want to show full shared screen (fit entire screen), use contain */
    .tile.screen video{ object-fit: contain !important; background:#000; }

    .label{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,.6);color:#fff;padding:6px;border-radius:8px;font-size:13px}
    .meta{position:absolute;right:8px;top:8px;background:rgba(0,0,0,.45);color:#fff;padding:4px 8px;border-radius:8px;font-size:12px}
    .chat{margin-top:12px;background:rgba(255,255,255,0.03);padding:10px;border-radius:8px}
    #messages{height:180px;overflow:auto;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
    .toast{position:fixed;right:16px;top:16px;background:rgba(0,0,0,.7);color:#fff;padding:10px;border-radius:8px}
    .controls-right{margin-left:auto;display:flex;gap:10px;align-items:center}
    @media (max-width:700px){
      .tile.fullscreen-share{ height:55vh; }
      /* mobile keep cover by default (face-centered) */
      video{ object-fit:cover; }
      .stage{ grid-template-columns: repeat(1, minmax(0, 1fr)); }
    }
  </style>
</head>
<body>
  <div class="top">
    <input id="name" placeholder="Your name" />
    <input id="room" value="testroom" />
    <button id="joinBtn">Join</button>
    <button id="startCallBtn" disabled>Start Call</button>
    <button id="leaveBtn" disabled class="ghost">Leave</button>
    <button id="muteBtn" disabled>Mute</button>
    <button id="camBtn" disabled>Cam Off</button>
    <button id="flipBtn" disabled>Flip</button>
    <button id="shareBtn" disabled>Share</button>
    <div class="controls-right">Socket: <span id="sid">-</span></div>
  </div>

  <div class="stage" id="stage"></div>

  <div class="chat">
    <strong>Chat</strong>
    <div id="messages"></div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <input id="chatInput" placeholder="Message..." style="flex:1" />
      <button id="sendBtn">Send</button>
    </div>
    <div id="memberList" style="margin-top:8px;color:#cbd5e1">Participants: <span id="count">0</span></div>
  </div>

  <div id="toastArea"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ======= CONFIG =======
    const socket = io(); // same-origin
    const STUN = { urls: 'stun:stun.l.google.com:19302' };

    // ======= UI refs =======
    const sidEl = document.getElementById('sid');
    const nameEl = document.getElementById('name');
    const roomEl = document.getElementById('room');
    const joinBtn = document.getElementById('joinBtn');
    const startCallBtn = document.getElementById('startCallBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const muteBtn = document.getElementById('muteBtn');
    const camBtn = document.getElementById('camBtn');
    const flipBtn = document.getElementById('flipBtn');
    const shareBtn = document.getElementById('shareBtn');
    const stage = document.getElementById('stage');
    const messagesDiv = document.getElementById('messages');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const countSpan = document.getElementById('count');
    const toastArea = document.getElementById('toastArea');

    // ======= State =======
    let localStream = null;
    let screenStream = null;
    let cameraTrack = null;
    let audioEnabled = true;
    let isSharing = false;
    let peers = {}; // id -> { pc, name, videoSender, audioSender }
    let room = null;
    let callStarted = false;
    let isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent || '');

    // ======= Helpers =======
    function toast(txt, ttl=1800){
      const d = document.createElement('div'); d.className='toast'; d.textContent = txt; toastArea.appendChild(d);
      setTimeout(()=>d.remove(), ttl);
    }

    function createTile(id, label, options = {}) {
      // options: { isLocal: bool, isScreen: bool }
      if(document.getElementById('tile-'+id)) return document.getElementById('tile-'+id);
      const div = document.createElement('div'); div.className='tile'; div.id='tile-'+id;
      if(options.isScreen) div.classList.add('screen'); // apply contain later
      const v = document.createElement('video'); v.id='video-'+id; v.autoplay=true; v.playsInline=true; if(options.isLocal) v.muted=true;
      const lab = document.createElement('div'); lab.className='label'; lab.textContent = label;
      div.appendChild(v); div.appendChild(lab); stage.appendChild(div);
      return div;
    }

    function setTileFullscreenForShare(sharerId) {
      document.querySelectorAll('.tile.fullscreen-share').forEach(el=>el.classList.remove('fullscreen-share'));
      if(!sharerId) return;
      const tile = document.getElementById('tile-'+sharerId);
      if(tile) tile.classList.add('fullscreen-share');
    }

    function removeTile(id){
      const el = document.getElementById('tile-'+id);
      if(el) el.remove();
    }

    function updateMemberList(members){
      const list = Array.isArray(members) ? members.map(m=>m.name||'Anonymous') : Object.values(peers).map(p=>p.name || 'User');
      countSpan.textContent = list.length;
      const memberListEl = document.getElementById('memberList');
      memberListEl.textContent = 'Participants: ' + (list.length ? list.join(', ') : '0');
    }

    function appendMessage(txt){
      const d = document.createElement('div'); d.textContent = txt; messagesDiv.appendChild(d); messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // ======= socket handlers =======
    socket.on('connect', ()=>{ sidEl.textContent = socket.id; });

    socket.on('require-name', ({message}) => { toast(message || 'Name required'); joinBtn.disabled = false; });

    socket.on('existingPeers', list => {
      (list || []).forEach(p => {
        if(p.id === socket.id) return;
        peers[p.id] = peers[p.id] || {}; peers[p.id].name = p.name || 'Peer';
        createTile(p.id, p.name || 'Peer');
      });
      updateMemberList(list);
    });

    socket.on('peer-joined', ({id, name, meta}) => {
      if(id === socket.id) return;
      peers[id] = peers[id] || {}; peers[id].name = name || 'Peer'; peers[id].meta = meta || {};
      createTile(id, peers[id].name);
      toast((name||'Peer') + ' joined');
      updateMemberList();
      if(callStarted) initPeer(id, true).catch(e=>console.warn(e));
    });

    socket.on('peer-left', ({id, name})=>{
      removeTile(id);
      if(peers[id] && peers[id].pc){ try{ peers[id].pc.close(); }catch(e){} }
      delete peers[id];
      toast((name||'Peer') + ' left');
      updateMemberList();
    });

    socket.on('roomMembers', payload => {
      const members = (payload && payload.members) ? payload.members : [];
      members.forEach(m=>{
        if(m.id === socket.id) return;
        peers[m.id] = peers[m.id] || {}; peers[m.id].name = m.name || 'Peer'; peers[m.id].meta = m.meta || {};
        createTile(m.id, peers[m.id].name);
      });
      const memberIds = new Set(members.map(m=>m.id));
      Object.keys(peers).forEach(id=>{ if(id !== socket.id && !memberIds.has(id)){ removeTile(id); delete peers[id]; }});
      updateMemberList(members);
    });

    socket.on('screenShare', ({ active, from }) => {
      if(active) {
        document.querySelectorAll('.tile').forEach(t=> t.classList.remove('screen'));
        const tile = document.getElementById('tile-'+from);
        if(tile) tile.classList.add('screen');
        setTileFullscreenForShare(from);
        toast('Screen shared by ' + (peers[from] && peers[from].name ? peers[from].name : 'Someone'));
      } else {
        document.querySelectorAll('.tile.screen').forEach(t=> t.classList.remove('screen'));
        setTileFullscreenForShare(null);
        toast('Screen sharing stopped');
      }
    });

    socket.on('roomDelta', delta=>{
      if(!delta) return;
      if(delta.joined && delta.joined.length) delta.joined.forEach(j=>{ peers[j.id] = peers[j.id] || {}; peers[j.id].name = j.name || 'Peer'; createTile(j.id, peers[j.id].name); });
      if(delta.left && delta.left.length) delta.left.forEach(l=>{ removeTile(l.id); delete peers[l.id]; });
      updateMemberList();
    });

    socket.on('chatMessage', ({from, name, text})=>{
      appendMessage((name||'Peer') + ': ' + text);
    });

    socket.on('signal', async ({ from, data })=>{
      if(!from || !data) return;
      let pc = peers[from] && peers[from].pc;
      if(!pc) pc = await initPeer(from, false);
      try {
        if(data.type === 'offer'){
          await pc.setRemoteDescription(new RTCSessionDescription(data));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('signal', { to: from, data: pc.localDescription });
        } else if(data.type === 'answer'){
          await pc.setRemoteDescription(new RTCSessionDescription(data));
        } else if(data.candidate){
          await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      } catch (err) { console.warn('signal handling failed', err); }
    });

    // ======= join flow =======
    joinBtn.onclick = async () => {
      const name = (nameEl.value || '').trim();
      const r = (roomEl.value || '').trim();
      if(!name || !r){ toast('Enter name & room'); return; }
      joinBtn.disabled = true;
      try {
        const constraints = isMobile
          ? { video: { width: { ideal: 720 }, height: { ideal: 1280 }, facingMode: 'user', aspectRatio: { ideal: 9/16 } }, audio: true }
          : { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user', aspectRatio: { ideal: 16/9 } }, audio: true };

        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraTrack = localStream.getVideoTracks()[0];
        audioEnabled = localStream.getAudioTracks().length ? localStream.getAudioTracks()[0].enabled : true;

        createTile(socket.id, name + ' (You)', { isLocal: true });
        const localVid = document.getElementById('video-'+socket.id);
        if(localVid) {
          localVid.srcObject = localStream;
          localVid.style.objectFit = 'cover';
          // mirror self-view for naturalness if front camera guessed
          try {
            const s = cameraTrack.getSettings();
            if(s && (s.facingMode === 'user' || s.facingMode === 'front')) localVid.style.transform = 'scaleX(-1)';
            else localVid.style.transform = '';
          } catch(e){ localVid.style.transform = 'scaleX(-1)'; }
        }

        startCallBtn.disabled = false; leaveBtn.disabled = false; muteBtn.disabled = false; camBtn.disabled = false; flipBtn.disabled = false; shareBtn.disabled = false;

        room = r;
        socket.emit('join', { room, name, clientMeta: detectMeta() });
      } catch (err) {
        toast('Camera/Mic error: ' + (err && err.message ? err.message : err));
        joinBtn.disabled = false;
      }
    };

    // ======= WebRTC helpers =======
    async function initPeer(id, isInitiator){
      if(peers[id] && peers[id].pc) return peers[id].pc;
      const pc = new RTCPeerConnection({ iceServers: [STUN] });
      peers[id] = peers[id] || {};
      peers[id].pc = pc;

      if(localStream){
        localStream.getTracks().forEach(track => {
          try {
            const sender = pc.addTrack(track, localStream);
            if(track.kind === 'video') peers[id].videoSender = sender;
            if(track.kind === 'audio') peers[id].audioSender = sender;
          } catch(e) { console.warn('addTrack failed', e); }
        });
      }

      pc.onicecandidate = e => { if(e.candidate) socket.emit('signal', { to: id, data: { candidate: e.candidate } }); };

      pc.ontrack = e => {
        createTile(id, peers[id].name || 'Peer');
        const remoteVid = document.getElementById('video-'+id);
        if(remoteVid) {
          remoteVid.srcObject = e.streams[0];
          const tile = document.getElementById('tile-'+id);
          if(tile && tile.classList.contains('screen')) {
            remoteVid.style.objectFit = 'contain';
          } else {
            remoteVid.style.objectFit = 'cover';
          }
          remoteVid.style.transform = '';
        }
      };

      if(isInitiator){
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit('signal', { to: id, data: pc.localDescription });
        } catch(e) { console.warn('offer failed', e); }
      }
      return pc;
    }

    // ======= start call =======
    startCallBtn.onclick = async () => {
      if(!room) return toast('Join a room first');
      callStarted = true;
      startCallBtn.disabled = true;
      const otherIds = Object.keys(peers).filter(id => id !== socket.id);
      for(const id of otherIds) { try { await initPeer(id, true); } catch(e){ console.warn(e); } }
      toast('Call started');
    };

    // ======= leave =======
    leaveBtn.onclick = () => {
      socket.emit('leave');
      Object.keys(peers).forEach(id => {
        if(peers[id].pc) try{ peers[id].pc.close(); }catch(e){}
        removeTile(id);
      });
      peers = {};
      callStarted = false;
      if(localStream) localStream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
      if(screenStream) screenStream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
      localStream = null; screenStream = null; cameraTrack = null;
      joinBtn.disabled = false; startCallBtn.disabled = true; leaveBtn.disabled = true; muteBtn.disabled = true; camBtn.disabled = true; flipBtn.disabled = true; shareBtn.disabled = true;
      document.querySelectorAll('[id^="tile-"]').forEach(el => el.remove());
      toast('Left room');
    };

    // ======= mute / cam toggle =======
    muteBtn.onclick = () => {
      if(!localStream) return toast('Join first');
      audioEnabled = !audioEnabled;
      localStream.getAudioTracks().forEach(t => t.enabled = audioEnabled);
      muteBtn.textContent = audioEnabled ? 'Mute' : 'Unmute';
      Object.values(peers).forEach(p => {
        if(p.audioSender && p.audioSender.track) try{ p.audioSender.track.enabled = audioEnabled; } catch(e){}
      });
    };

    camBtn.onclick = () => {
      if(!localStream) return toast('Join first');
      const videoTracks = localStream.getVideoTracks();
      if(!videoTracks || videoTracks.length === 0) return toast('No camera track');
      const enabled = videoTracks[0].enabled;
      videoTracks.forEach(t => t.enabled = !enabled);
      camBtn.textContent = enabled ? 'Cam On' : 'Cam Off';
    };

    // ======= flip camera (mobile) =======
    function isFrontTrack(track){
      if(!track || !track.getSettings) return false;
      const s = track.getSettings();
      if(s && s.facingMode) return s.facingMode === 'user' || s.facingMode === 'front';
      try {
        const lab = (track.label || '').toLowerCase();
        return lab.includes('front') || lab.includes('facing front') || lab.includes('user');
      } catch(e){ return false; }
    }

    flipBtn.onclick = async () => {
      try {
        if(!localStream) return toast('Join first');
        const devices = await navigator.mediaDevices.enumerateDevices();
        const vids = devices.filter(d => d.kind === 'videoinput');
        if(vids.length < 2) return toast('No second camera found');

        const currentId = cameraTrack && cameraTrack.getSettings && cameraTrack.getSettings().deviceId;
        let idx = vids.findIndex(v => v.deviceId === currentId);
        idx = (idx + 1) % vids.length;
        const nextId = vids[idx].deviceId;

        // request only the new video track
        const newCamStream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: { exact: nextId }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        const newTrack = newCamStream.getVideoTracks()[0];

        // Replace on peer senders FIRST
        await Promise.all(Object.values(peers).map(async p => {
          if(p.videoSender && p.videoSender.replaceTrack) {
            try { await p.videoSender.replaceTrack(newTrack); } catch(e){ console.warn('replaceTrack failed', e); }
          } else if(p.pc) {
            try {
              p.pc.getSenders().forEach(s => { if(s.track && s.track.kind === 'video') try{ p.pc.removeTrack(s); }catch(e){} });
              const snd = p.pc.addTrack(newTrack, localStream);
              p.videoSender = snd;
            } catch(e){ console.warn('fallback addTrack failed', e); }
          }
        }));

        // Now swap localStream tracks cleanly
        localStream.getVideoTracks().forEach(t => { try{ localStream.removeTrack(t); }catch(e){} });
        try { if(cameraTrack) cameraTrack.stop(); } catch(e){}
        localStream.addTrack(newTrack);
        cameraTrack = newTrack;

        // update local preview
        const myVid = document.getElementById('video-'+socket.id);
        if(myVid) {
          myVid.srcObject = null;
          myVid.srcObject = localStream;
          if(isFrontTrack(newTrack)) myVid.style.transform = 'scaleX(-1)';
          else myVid.style.transform = '';
          myVid.style.objectFit = 'cover';
        }

      } catch (e) { toast('Flip failed: ' + (e && e.message ? e.message : e)); }
    };

    // ======= screen share (fullscreen-friendly) =======
    shareBtn.onclick = async () => {
      if(!localStream) return toast('Join first');
      if(!isSharing) {
        try {
          screenStream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: 'always' }, audio: false });
          const screenTrack = screenStream.getVideoTracks()[0];
          screenTrack.onended = () => { stopScreenShare(); };
          // replace camera video track in localStream
          if(cameraTrack) { try { localStream.removeTrack(cameraTrack); }catch(e){} try{ cameraTrack.stop(); }catch(e){} }
          localStream.addTrack(screenTrack);
          cameraTrack = screenTrack;
          // replace on all peer senders
          Object.values(peers).forEach(async p => {
            if(p.videoSender && p.videoSender.replaceTrack) {
              try { await p.videoSender.replaceTrack(screenTrack); } catch(e){ console.warn('replaceTrack failed', e); }
            } else if(p.pc) {
              try {
                p.pc.getSenders().forEach(s => { if(s.track && s.track.kind === 'video') try{ p.pc.removeTrack(s); }catch(e){} });
                const snd = p.pc.addTrack(screenTrack, localStream);
                p.videoSender = snd;
              } catch(e){ console.warn('fallback addTrack failed', e); }
            }
          });
          const myTile = document.getElementById('tile-'+socket.id) || createTile(socket.id, (nameEl.value||'You') + ' (You)', { isLocal:true });
          myTile.classList.add('screen');
          socket.emit('screenShare', { active: true, from: socket.id });
          isSharing = true;
          shareBtn.textContent = 'Stop';
          const v = document.getElementById('video-'+socket.id); if(v) { v.srcObject = localStream; v.style.objectFit = 'contain'; v.style.transform = ''; }
        } catch(e) { toast('Screen share failed: ' + (e && e.message ? e.message : e)); }
      } else {
        stopScreenShare();
      }
    };

    async function stopScreenShare(){
      if(!isSharing) return;
      try {
        if(screenStream) screenStream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
        screenStream = null;
        // reacquire camera
        try {
          const cam = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          const newTrack = cam.getVideoTracks()[0];
          localStream.getVideoTracks().forEach(t => { try{ localStream.removeTrack(t); }catch(e){} });
          localStream.addTrack(newTrack);
          cameraTrack = newTrack;
        } catch(e) { console.warn('could not reacquire camera', e); }
        // replace senders
        Object.values(peers).forEach(async p => {
          if(p.videoSender && p.videoSender.replaceTrack) {
            try { await p.videoSender.replaceTrack(cameraTrack); } catch(e){ console.warn('replaceTrack failed', e); }
          } else if(p.pc) {
            try {
              p.pc.getSenders().forEach(s => { if(s.track && s.track.kind === 'video') try{ p.pc.removeTrack(s); }catch(e){} });
              const snd = p.pc.addTrack(cameraTrack, localStream);
              p.videoSender = snd;
            } catch(e){ console.warn('fallback addTrack failed', e); }
          }
        });
        const myTile = document.getElementById('tile-'+socket.id); if(myTile) myTile.classList.remove('screen');
        socket.emit('screenShare', { active: false, from: socket.id });
        isSharing = false;
        shareBtn.textContent = 'Share';
        const v = document.getElementById('video-'+socket.id); if(v) v.srcObject = localStream;
      } catch(e){ console.warn('stopScreenShare error', e); isSharing=false; shareBtn.textContent='Share'; socket.emit('screenShare', { active:false, from: socket.id }); }
    }

    // ======= chat =======
    sendBtn.onclick = () => {
      const txt = chatInput.value.trim(); if(!txt) return;
      socket.emit('chatMessage', { room, text: txt });
      appendMessage('You: ' + txt); chatInput.value = '';
    };

    // ======= utility meta =======
    function detectMeta(){
      const ua = navigator.userAgent || '';
      const tz = (()=>{ try{ return Intl.DateTimeFormat().resolvedOptions().timeZone }catch(e){ return 'unknown' } })();
      let countryGuess = null;
      const lang = (navigator.language||'').toLowerCase();
      if(lang.includes('en-us')) countryGuess = 'US';
      if(tz && tz.toLowerCase().includes('america')) countryGuess = 'US';
      return { isMobile, deviceType: isMobile ? 'mobile' : 'desktop', language: navigator.language, timezone: tz, countryGuess, userAgent: ua };
    }

    // cleanup on tab close
    window.addEventListener('beforeunload', ()=>{ try{ socket.emit('leave'); }catch(e){} });
  </script>
</body>
</html>
