<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Video Call â€” Modern UI (Join Fixed)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>

<style>
:root{
  --bg:#020617;
  --panel:#0f172a;
  --border:#1e293b;
  --text:#e5e7eb;
  --muted:#94a3b8;
  --accent:#0ea5e9;
}
*{box-sizing:border-box}

body{
  margin:0;
  font-family:Inter,Arial,sans-serif;
  background:var(--bg);
  color:var(--text);
  height:100vh;
  display:flex;
  flex-direction:column;
}

/* HEADER */
.header{
  height:60px;
  background:var(--panel);
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:0 16px;
  border-bottom:1px solid var(--border);
}
.header-left{display:flex;gap:8px;align-items:center}
.header-right{color:var(--muted);font-size:14px}

input{
  background:#020617;
  border:1px solid var(--border);
  color:var(--text);
  padding:8px 10px;
  border-radius:8px;
}

.btn{
  background:linear-gradient(135deg,#2563eb,#0ea5e9);
  border:none;
  color:white;
  padding:8px 14px;
  border-radius:10px;
  cursor:pointer;
  transition:.25s;
}
.btn:hover{transform:scale(1.05);box-shadow:0 0 12px rgba(14,165,233,.6)}
.btn.ghost{background:transparent;border:1px solid var(--accent);color:var(--accent)}
.btn:disabled{opacity:.5;cursor:not-allowed}

/* MAIN */
.main{flex:1;display:flex;overflow:hidden}

/* STAGE */
.stage{
  flex:1;
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(280px,1fr));
  gap:12px;
  padding:12px;
  overflow:auto;
}
.tile{
  background:black;
  border-radius:16px;
  overflow:hidden;
  position:relative;
  aspect-ratio:16/9;
  box-shadow:0 10px 30px rgba(0,0,0,.5);
}
.tile video{width:100%;height:100%;object-fit:cover}
.tile.screen video{object-fit:contain}
.tile.fullscreen-share{grid-column:1/-1;height:65vh}
.tile.mini{position:fixed;width:260px;bottom:80px;right:20px;z-index:999}
.label{
  position:absolute;
  bottom:10px;
  left:10px;
  background:rgba(0,0,0,.6);
  padding:6px 10px;
  border-radius:8px;
  font-size:13px;
}

/* CHAT */
.chat{
  width:320px;
  background:var(--panel);
  border-left:1px solid var(--border);
  display:flex;
  flex-direction:column;
}
.chat-header{padding:10px;border-bottom:1px solid var(--border);font-weight:600}
#messages{flex:1;overflow:auto;padding:10px}
#messages div{
  background:#020617;
  padding:6px 10px;
  border-radius:8px;
  margin-bottom:6px;
}
.chat-input{display:flex;gap:8px;padding:10px;border-top:1px solid var(--border)}

/* FOOTER */
.footer{
  height:64px;
  background:var(--panel);
  border-top:1px solid var(--border);
  display:flex;
  align-items:center;
  justify-content:center;
  gap:10px;
}

/* TOAST */
.toast{
  position:fixed;
  top:20px;
  right:20px;
  background:rgba(0,0,0,.7);
  padding:10px 14px;
  border-radius:10px;
  z-index:999;
}

@media(max-width:800px){
  .chat{display:none}
  .stage{grid-template-columns:1fr}
}
</style>
</head>

<body>

<!-- HEADER (JOIN HERE âœ…) -->
<div class="header">
  <div class="header-left">
    <input id="name" placeholder="Your name">
    <input id="room" value="testroom">
    <button class="btn" id="joinBtn">Join</button>
  </div>
  <div class="header-right">
    Socket: <span id="sid">-</span>
  </div>
</div>

<!-- MAIN -->
<div class="main">
  <div class="stage" id="stage">
    <div style="margin:auto;color:#64748b">
      Enter name & room â†’ Click Join
    </div>
  </div>

  <div class="chat">
    <div class="chat-header">Chat</div>
    <div id="messages"></div>
    <div class="chat-input">
      <input id="chatInput" placeholder="Message..." style="flex:1">
      <button class="btn" id="sendBtn">Send</button>
    </div>
    <div style="padding:8px;color:#94a3b8">
      Participants: <span id="count">0</span>
    </div>
  </div>
</div>

<!-- FOOTER CONTROLS -->
<div class="footer">
  <button class="btn" id="startCallBtn" disabled>Start</button>
  <button class="btn" id="muteBtn" disabled>Mute</button>
  <button class="btn" id="camBtn" disabled>Cam</button>
  <button class="btn" id="flipBtn" disabled>Flip</button>
  <button class="btn" id="shareBtn" disabled>Share</button>
  <button class="btn ghost" id="leaveBtn" disabled>Leave</button>
  <button class="btn ghost" onclick="toggleMini()">Mini</button>
</div>

<div id="toastArea"></div>

<!-- ðŸ”´ SAME JS AS YOU SENT (NO CHANGE) -->
 <script src="/socket.io/socket.io.js"></script>
  <script>
    /* ===== ADD: mini toggle (NO logic removed) ===== */
function toggleMini(){
  const tile = document.getElementById('tile-'+socket.id);
  if(tile) tile.classList.toggle('mini');
}
    // ======= CONFIG =======
    const socket = io(); // same-origin
    const STUN = { urls: 'stun:stun.l.google.com:19302' };

    // ======= UI refs =======
    const sidEl = document.getElementById('sid');
    const nameEl = document.getElementById('name');
    const roomEl = document.getElementById('room');
    const joinBtn = document.getElementById('joinBtn');
    const startCallBtn = document.getElementById('startCallBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const muteBtn = document.getElementById('muteBtn');
    const camBtn = document.getElementById('camBtn');
    const flipBtn = document.getElementById('flipBtn');
    const shareBtn = document.getElementById('shareBtn');
    const stage = document.getElementById('stage');
    const messagesDiv = document.getElementById('messages');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const countSpan = document.getElementById('count');
    const toastArea = document.getElementById('toastArea');

    // ======= State =======
    let localStream = null;
    let screenStream = null;
    let cameraTrack = null;
    let audioEnabled = true;
    let isSharing = false;
    let peers = {}; // id -> { pc, name, videoSender, audioSender }
    let room = null;
    let callStarted = false;
    let isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent || '');

    // ======= Helpers =======
    function toast(txt, ttl=1800){
      const d = document.createElement('div'); d.className='toast'; d.textContent = txt; toastArea.appendChild(d);
      setTimeout(()=>d.remove(), ttl);
    }

    function createTile(id, label, options = {}) {
      // options: { isLocal: bool, isScreen: bool }
      if(document.getElementById('tile-'+id)) return document.getElementById('tile-'+id);
      const div = document.createElement('div'); div.className='tile'; div.id='tile-'+id;
      if(options.isScreen) div.classList.add('screen'); // apply contain later
      const v = document.createElement('video'); v.id='video-'+id; v.autoplay=true; v.playsInline=true; if(options.isLocal) v.muted=true;
      const lab = document.createElement('div'); lab.className='label'; lab.textContent = label;
      div.appendChild(v); 
      div.appendChild(lab); 
      // ðŸ‘‡ CLICK TO FOCUS
      div.onclick = () => focusTile(id);
      stage.appendChild(div);
      return div;
    }

    function setTileFullscreenForShare(sharerId) {
  document.querySelectorAll('.tile').forEach(t=>{
    t.classList.remove('fullscreen-share');
  });

  if(!sharerId) return;

  const tile = document.getElementById('tile-'+sharerId);
  if(tile){
    tile.classList.add('fullscreen-share');
  }
}


    function removeTile(id){
      const el = document.getElementById('tile-'+id);
      if(el) el.remove();
    }

    function updateMemberList(members){
      const list = Array.isArray(members) ? members.map(m=>m.name||'Anonymous') : Object.values(peers).map(p=>p.name || 'User');
      countSpan.textContent = list.length;
      const memberListEl = document.getElementById('memberList');
      memberListEl.textContent = 'Participants: ' + (list.length ? list.join(', ') : '0');
    }

    function appendMessage(txt){
      const d = document.createElement('div'); d.textContent = txt; messagesDiv.appendChild(d); messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // ======= socket handlers =======
    socket.on('connect', ()=>{ sidEl.textContent = socket.id; });

    socket.on('require-name', ({message}) => { toast(message || 'Name required'); joinBtn.disabled = false; });

    socket.on('existingPeers', list => {
      (list || []).forEach(p => {
        if(p.id === socket.id) return;
        peers[p.id] = peers[p.id] || {}; peers[p.id].name = p.name || 'Peer';
        createTile(p.id, p.name || 'Peer');
      });
      updateMemberList(list);
    });

    socket.on('peer-joined', ({id, name, meta}) => {
      if(id === socket.id) return;
      peers[id] = peers[id] || {}; peers[id].name = name || 'Peer'; peers[id].meta = meta || {};
      createTile(id, peers[id].name);
      toast((name||'Peer') + ' joined');
      updateMemberList();
      if(callStarted) initPeer(id, true).catch(e=>console.warn(e));
    });

    socket.on('peer-left', ({id, name})=>{
      removeTile(id);
      if(peers[id] && peers[id].pc){ try{ peers[id].pc.close(); }catch(e){} }
      delete peers[id];
      toast((name||'Peer') + ' left');
      updateMemberList();
    });

    socket.on('roomMembers', payload => {
      const members = (payload && payload.members) ? payload.members : [];
      members.forEach(m=>{
        if(m.id === socket.id) return;
        peers[m.id] = peers[m.id] || {}; peers[m.id].name = m.name || 'Peer'; peers[m.id].meta = m.meta || {};
        createTile(m.id, peers[m.id].name);
      });
      const memberIds = new Set(members.map(m=>m.id));
      Object.keys(peers).forEach(id=>{ if(id !== socket.id && !memberIds.has(id)){ removeTile(id); delete peers[id]; }});
      updateMemberList(members);
    });

    socket.on('screenShare', ({ active, from }) => {
      if(active) {
        document.querySelectorAll('.tile').forEach(t=> t.classList.remove('screen'));
        const tile = document.getElementById('tile-'+from);
        if(tile) tile.classList.add('screen');
        setTileFullscreenForShare(from);
        toast('Screen shared by ' + (peers[from] && peers[from].name ? peers[from].name : 'Someone'));
      } else {
        document.querySelectorAll('.tile.screen').forEach(t=> t.classList.remove('screen'));
        setTileFullscreenForShare(null);
        toast('Screen sharing stopped');
      }
    });

    socket.on('roomDelta', delta=>{
      if(!delta) return;
      if(delta.joined && delta.joined.length) delta.joined.forEach(j=>{ peers[j.id] = peers[j.id] || {}; peers[j.id].name = j.name || 'Peer'; createTile(j.id, peers[j.id].name); });
      if(delta.left && delta.left.length) delta.left.forEach(l=>{ removeTile(l.id); delete peers[l.id]; });
      updateMemberList();
    });

    socket.on('chatMessage', ({from, name, text})=>{
      appendMessage((name||'Peer') + ': ' + text);
    });

    socket.on('signal', async ({ from, data })=>{
      if(!from || !data) return;
      let pc = peers[from] && peers[from].pc;
      if(!pc) pc = await initPeer(from, false);
      try {
        if(data.type === 'offer'){
          await pc.setRemoteDescription(new RTCSessionDescription(data));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('signal', { to: from, data: pc.localDescription });
        } else if(data.type === 'answer'){
          await pc.setRemoteDescription(new RTCSessionDescription(data));
        } else if(data.candidate){
          await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      } catch (err) { console.warn('signal handling failed', err); }
    });

    // ======= join flow =======
    joinBtn.onclick = async () => {
      const name = (nameEl.value || '').trim();
      const r = (roomEl.value || '').trim();
      if(!name || !r){ toast('Enter name & room'); return; }
      joinBtn.disabled = true;
      try {
        const constraints = isMobile
          ? { video: { width: { ideal: 720 }, height: { ideal: 1280 }, facingMode: 'user', aspectRatio: { ideal: 9/16 } }, audio: true }
          : { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user', aspectRatio: { ideal: 16/9 } }, audio: true };

        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraTrack = localStream.getVideoTracks()[0];
        audioEnabled = localStream.getAudioTracks().length ? localStream.getAudioTracks()[0].enabled : true;

        createTile(socket.id, name + ' (You)', { isLocal: true });
        const localVid = document.getElementById('video-'+socket.id);
        if(localVid) {
          localVid.srcObject = localStream;
          localVid.style.objectFit = 'cover';
          // mirror self-view for naturalness if front camera guessed
          try {
            const s = cameraTrack.getSettings();
            if(s && (s.facingMode === 'user' || s.facingMode === 'front')) localVid.style.transform = 'scaleX(-1)';
            else localVid.style.transform = '';
          } catch(e){ localVid.style.transform = 'scaleX(-1)'; }
        }

        startCallBtn.disabled = false; leaveBtn.disabled = false; muteBtn.disabled = false; camBtn.disabled = false; flipBtn.disabled = false; shareBtn.disabled = false;

        room = r;
        socket.emit('join', { room, name, clientMeta: detectMeta() });
      } catch (err) {
        toast('Camera/Mic error: ' + (err && err.message ? err.message : err));
        joinBtn.disabled = false;
      }
    };

    // ======= WebRTC helpers =======
    async function initPeer(id, isInitiator){
      if(peers[id] && peers[id].pc) return peers[id].pc;
      const pc = new RTCPeerConnection({ iceServers: [STUN] });
      peers[id] = peers[id] || {};
      peers[id].pc = pc;

      if(localStream){
        localStream.getTracks().forEach(track => {
          try {
            const sender = pc.addTrack(track, localStream);
            if(track.kind === 'video') peers[id].videoSender = sender;
            if(track.kind === 'audio') peers[id].audioSender = sender;
          } catch(e) { console.warn('addTrack failed', e); }
        });
      }

      pc.onicecandidate = e => { if(e.candidate) socket.emit('signal', { to: id, data: { candidate: e.candidate } }); };

      pc.ontrack = e => {
        createTile(id, peers[id].name || 'Peer');
        const remoteVid = document.getElementById('video-'+id);
        if(remoteVid) {
          remoteVid.srcObject = e.streams[0];
          const tile = document.getElementById('tile-'+id);
          if(tile && tile.classList.contains('screen')) {
            remoteVid.style.objectFit = 'contain';
          } else {
            remoteVid.style.objectFit = 'cover';
          }
          remoteVid.style.transform = '';
        }
      };

      if(isInitiator){
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit('signal', { to: id, data: pc.localDescription });
        } catch(e) { console.warn('offer failed', e); }
      }
      return pc;
    }

    // ======= start call =======
    startCallBtn.onclick = async () => {
      if(!room) return toast('Join a room first');
      callStarted = true;
      startCallBtn.disabled = true;
      const otherIds = Object.keys(peers).filter(id => id !== socket.id);
      for(const id of otherIds) { try { await initPeer(id, true); } catch(e){ console.warn(e); } }
      toast('Call started');
    };

    // ======= leave =======
    leaveBtn.onclick = () => {
      socket.emit('leave');
      Object.keys(peers).forEach(id => {
        if(peers[id].pc) try{ peers[id].pc.close(); }catch(e){}
        removeTile(id);
      });
      peers = {};
      callStarted = false;
      if(localStream) localStream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
      if(screenStream) screenStream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
      localStream = null; screenStream = null; cameraTrack = null;
      joinBtn.disabled = false; startCallBtn.disabled = true; leaveBtn.disabled = true; muteBtn.disabled = true; camBtn.disabled = true; flipBtn.disabled = true; shareBtn.disabled = true;
      document.querySelectorAll('[id^="tile-"]').forEach(el => el.remove());
      toast('Left room');
    };

    // ======= mute / cam toggle =======
    muteBtn.onclick = () => {
      if(!localStream) return toast('Join first');
      audioEnabled = !audioEnabled;
      localStream.getAudioTracks().forEach(t => t.enabled = audioEnabled);
      muteBtn.textContent = audioEnabled ? 'Mute' : 'Unmute';
      Object.values(peers).forEach(p => {
        if(p.audioSender && p.audioSender.track) try{ p.audioSender.track.enabled = audioEnabled; } catch(e){}
      });
    };

    camBtn.onclick = () => {
      if(!localStream) return toast('Join first');
      const videoTracks = localStream.getVideoTracks();
      if(!videoTracks || videoTracks.length === 0) return toast('No camera track');
      const enabled = videoTracks[0].enabled;
      videoTracks.forEach(t => t.enabled = !enabled);
      camBtn.textContent = enabled ? 'Cam On' : 'Cam Off';
    };

    // ======= flip camera (mobile) =======
    function isFrontTrack(track){
      if(!track || !track.getSettings) return false;
      const s = track.getSettings();
      if(s && s.facingMode) return s.facingMode === 'user' || s.facingMode === 'front';
      try {
        const lab = (track.label || '').toLowerCase();
        return lab.includes('front') || lab.includes('facing front') || lab.includes('user');
      } catch(e){ return false; }
    }

    flipBtn.onclick = async () => {
      try {
        if(!localStream) return toast('Join first');
        const devices = await navigator.mediaDevices.enumerateDevices();
        const vids = devices.filter(d => d.kind === 'videoinput');
        if(vids.length < 2) return toast('No second camera found');

        const currentId = cameraTrack && cameraTrack.getSettings && cameraTrack.getSettings().deviceId;
        let idx = vids.findIndex(v => v.deviceId === currentId);
        idx = (idx + 1) % vids.length;
        const nextId = vids[idx].deviceId;

        // request only the new video track
        const newCamStream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: { exact: nextId }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        const newTrack = newCamStream.getVideoTracks()[0];

        // Replace on peer senders FIRST
        await Promise.all(Object.values(peers).map(async p => {
          if(p.videoSender && p.videoSender.replaceTrack) {
            try { await p.videoSender.replaceTrack(newTrack); } catch(e){ console.warn('replaceTrack failed', e); }
          } else if(p.pc) {
            try {
              p.pc.getSenders().forEach(s => { if(s.track && s.track.kind === 'video') try{ p.pc.removeTrack(s); }catch(e){} });
              const snd = p.pc.addTrack(newTrack, localStream);
              p.videoSender = snd;
            } catch(e){ console.warn('fallback addTrack failed', e); }
          }
        }));

        // Now swap localStream tracks cleanly
        localStream.getVideoTracks().forEach(t => { try{ localStream.removeTrack(t); }catch(e){} });
        try { if(cameraTrack) cameraTrack.stop(); } catch(e){}
        localStream.addTrack(newTrack);
        cameraTrack = newTrack;

        // update local preview
        const myVid = document.getElementById('video-'+socket.id);
        if(myVid) {
          myVid.srcObject = null;
          myVid.srcObject = localStream;
          if(isFrontTrack(newTrack)) myVid.style.transform = 'scaleX(-1)';
          else myVid.style.transform = '';
          myVid.style.objectFit = 'cover';
        }

      } catch (e) { toast('Flip failed: ' + (e && e.message ? e.message : e)); }
    };

    // ======= screen share (fullscreen-friendly) =======
    shareBtn.onclick = async () => {
      if(!localStream) return toast('Join first');
      if(!isSharing) {
        try {
          screenStream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: 'always' }, audio: false });
          const screenTrack = screenStream.getVideoTracks()[0];
          screenTrack.onended = () => { stopScreenShare(); };
          // replace camera video track in localStream
          if(cameraTrack) { try { localStream.removeTrack(cameraTrack); }catch(e){} try{ cameraTrack.stop(); }catch(e){} }
          localStream.addTrack(screenTrack);
          cameraTrack = screenTrack;
          // replace on all peer senders
          Object.values(peers).forEach(async p => {
            if(p.videoSender && p.videoSender.replaceTrack) {
              try { await p.videoSender.replaceTrack(screenTrack); } catch(e){ console.warn('replaceTrack failed', e); }
            } else if(p.pc) {
              try {
                p.pc.getSenders().forEach(s => { if(s.track && s.track.kind === 'video') try{ p.pc.removeTrack(s); }catch(e){} });
                const snd = p.pc.addTrack(screenTrack, localStream);
                p.videoSender = snd;
              } catch(e){ console.warn('fallback addTrack failed', e); }
            }
          });
          const myTile = document.getElementById('tile-'+socket.id) || createTile(socket.id, (nameEl.value||'You') + ' (You)', { isLocal:true });
          myTile.classList.add('screen');
          socket.emit('screenShare', { active: true, from: socket.id });
          isSharing = true;
          shareBtn.textContent = 'Stop';
          const v = document.getElementById('video-'+socket.id); if(v) { v.srcObject = localStream; v.style.objectFit = 'contain'; v.style.transform = ''; }
        } catch(e) { toast('Screen share failed: ' + (e && e.message ? e.message : e)); }
      } else {
        stopScreenShare();
      }
    };

    async function stopScreenShare(){
      if(!isSharing) return;
      try {
        if(screenStream) screenStream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
        screenStream = null;
        // reacquire camera
        try {
          const cam = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          const newTrack = cam.getVideoTracks()[0];
          localStream.getVideoTracks().forEach(t => { try{ localStream.removeTrack(t); }catch(e){} });
          localStream.addTrack(newTrack);
          cameraTrack = newTrack;
        } catch(e) { console.warn('could not reacquire camera', e); }
        // replace senders
        Object.values(peers).forEach(async p => {
          if(p.videoSender && p.videoSender.replaceTrack) {
            try { await p.videoSender.replaceTrack(cameraTrack); } catch(e){ console.warn('replaceTrack failed', e); }
          } else if(p.pc) {
            try {
              p.pc.getSenders().forEach(s => { if(s.track && s.track.kind === 'video') try{ p.pc.removeTrack(s); }catch(e){} });
              const snd = p.pc.addTrack(cameraTrack, localStream);
              p.videoSender = snd;
            } catch(e){ console.warn('fallback addTrack failed', e); }
          }
        });
        const myTile = document.getElementById('tile-'+socket.id); if(myTile) myTile.classList.remove('screen');
        socket.emit('screenShare', { active: false, from: socket.id });
        isSharing = false;
        shareBtn.textContent = 'Share';
        const v = document.getElementById('video-'+socket.id); if(v) v.srcObject = localStream;
      } catch(e){ console.warn('stopScreenShare error', e); isSharing=false; shareBtn.textContent='Share'; socket.emit('screenShare', { active:false, from: socket.id }); }
    }

    // ======= chat =======
    sendBtn.onclick = () => {
      const txt = chatInput.value.trim(); if(!txt) return;
      socket.emit('chatMessage', { room, text: txt });
      appendMessage('You: ' + txt); chatInput.value = '';
    };

    // ======= utility meta =======
    function detectMeta(){
      const ua = navigator.userAgent || '';
      const tz = (()=>{ try{ return Intl.DateTimeFormat().resolvedOptions().timeZone }catch(e){ return 'unknown' } })();
      let countryGuess = null;
      const lang = (navigator.language||'').toLowerCase();
      if(lang.includes('en-us')) countryGuess = 'US';
      if(tz && tz.toLowerCase().includes('america')) countryGuess = 'US';
      return { isMobile, deviceType: isMobile ? 'mobile' : 'desktop', language: navigator.language, timezone: tz, countryGuess, userAgent: ua };
    }
function focusTile(id){
  const tile = document.getElementById('tile-'+id);
  if(!tile) return;

  const isAlreadyFocused = tile.classList.contains('fullscreen-share');

  // sab fullscreen hatao
  document.querySelectorAll('.tile').forEach(t=>{
    t.classList.remove('fullscreen-share');
  });

  // agar pehle focused nahi tha â†’ fullscreen karo
  if(!isAlreadyFocused){
    tile.classList.add('fullscreen-share');
  }
}

    // cleanup on tab close
    window.addEventListener('beforeunload', ()=>{ try{ socket.emit('leave'); }catch(e){} });
  </script>

</body>
</html>
